# 4 RESULTADOS

## 4.1 Framework Scrum

### 4.1.1 Product backlog

O Product Backlog é uma lista dinâmica de funcionalidades e características desejadas para o sistema de gestão de segurança predial. Este backlog inclui requisitos funcionais e não funcionais que guiam o desenvolvimento do projeto.

#### 4.1.1.1 Requisitos funcionais

Os requisitos funcionais foram classificados como sendo todas as necessidades, funcionalidades ou características que são esperadas no software desenvolvido. Portanto, os quadros de 1 a 9 listam os requisitos funcionais do sistema, contendo seu identificador, nome, data de criação, data da última alteração, prioridade, versão, e descrição.

**Quadro 1 - Sistema de Autenticação**

| Identificador | RF001 |
|---------------|-------|
| Nome | Sistema de Autenticação |
| Data de criação | 01/02/2024 |
| Data da última alteração | 15/08/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | O sistema deve implementar autenticação segura com JWT e controle de acesso baseado em papéis (Admin, Supervisor, Agente). |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 2 - Gestão de Rondas**

| Identificador | RF002 |
|---------------|-------|
| Nome | Gestão de Rondas |
| Data de criação | 15/05/2024 |
| Data da última alteração | 15/06/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | Sistema para cadastro, programação e execução de rondas com controle de plantões, múltiplos condomínios e geração de relatórios automatizados. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 3 - Gestão de Ocorrências**

| Identificador | RF003 |
|---------------|-------|
| Nome | Gestão de Ocorrências |
| Data de criação | 15/06/2024 |
| Data da última alteração | 15/07/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | Registro e classificação automática de ocorrências com workflow de atendimento e integração com órgãos públicos. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 4 - Inteligência Artificial**

| Identificador | RF004 |
|---------------|-------|
| Nome | Inteligência Artificial |
| Data de criação | 15/07/2024 |
| Data da última alteração | 15/08/2024 |
| Prioridade | Média |
| Versão | 1.0 |
| Descrição | Integração com Google Gemini para classificação automática de ocorrências e geração de insights de segurança. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 5 - Banco de Dados**

| Identificador | RF005 |
|---------------|-------|
| Nome | Banco de Dados |
| Data de criação | 01/02/2024 |
| Data da última alteração | 15/08/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | Implementar banco de dados PostgreSQL para armazenar dados de usuários, rondas, ocorrências e colaboradores com relacionamentos e integridade referencial. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 6 - Gestão de Colaboradores**

| Identificador | RF006 |
|---------------|-------|
| Nome | Gestão de Colaboradores |
| Data de criação | 15/03/2024 |
| Data da última alteração | 15/04/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | Cadastro e gestão de colaboradores, escalas mensais e controle de plantões diurnos/noturnos. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 7 - Gestão de Condomínios**

| Identificador | RF007 |
|---------------|-------|
| Nome | Gestão de Condomínios |
| Data de criação | 15/04/2024 |
| Data da última alteração | 15/05/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | Cadastro e gestão de condomínios atendidos, incluindo endereços, contatos e informações de acesso. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 8 - Sistema de Notificações**

| Identificador | RF008 |
|---------------|-------|
| Nome | Sistema de Notificações |
| Data de criação | 15/07/2024 |
| Data da última alteração | 15/08/2024 |
| Prioridade | Média |
| Versão | 1.0 |
| Descrição | Sistema de notificações automáticas para supervisores sobre ocorrências, rondas pendentes e alertas de segurança. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 9 - Relatórios e Analytics**

| Identificador | RF009 |
|---------------|-------|
| Nome | Relatórios e Analytics |
| Data de criação | 15/08/2024 |
| Data da última alteração | 15/09/2024 |
| Prioridade | Média |
| Versão | 1.0 |
| Descrição | Geração de relatórios detalhados de rondas, ocorrências e análises de padrões de segurança. |

*Fonte: Elaborado pelo autor (2025)*

#### 4.1.1.2 Requisitos não funcionais

Os requisitos não funcionais descrevem uma funcionalidade, necessidade ou característica que o sistema deve conter, ou seja, uma descrição de como o sistema realizará determinada função. Desta forma, nos quadros de 10 até 13 estão listados os requisitos não funcionais do sistema, contendo seu identificador, nome, data de criação, data da última alteração, prioridade, versão, e descrição.

**Quadro 10 - Segurança de Dados**

| Identificador | RNF001 |
|---------------|--------|
| Nome | Segurança de Dados |
| Data de criação | 01/02/2024 |
| Data da última alteração | 15/09/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | Garantir criptografia de dados sensíveis, logs de auditoria completos e proteção contra ataques CSRF e XSS. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 11 - Performance**

| Identificador | RNF002 |
|---------------|--------|
| Nome | Performance |
| Data de criação | 01/02/2024 |
| Data da última alteração | 15/09/2024 |
| Prioridade | Alta |
| Versão | 1.0 |
| Descrição | Tempo de resposta < 2 segundos para operações críticas e suporte a 100 usuários simultâneos. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 12 - Usabilidade**

| Identificador | RNF003 |
|---------------|--------|
| Nome | Usabilidade |
| Data de criação | 01/02/2024 |
| Data da última alteração | 15/09/2024 |
| Prioridade | Média |
| Versão | 1.0 |
| Descrição | Interface responsiva para dispositivos móveis e tempo de aprendizado < 30 minutos. |

*Fonte: Elaborado pelo autor (2025)*

**Quadro 13 - Escalabilidade**

| Identificador | RNF004 |
|---------------|--------|
| Nome | Escalabilidade |
| Data de criação | 01/02/2024 |
| Data da última alteração | 15/09/2024 |
| Prioridade | Média |
| Versão | 1.0 |
| Descrição | Disponibilidade de 99.5% e cache inteligente para consultas frequentes. |

*Fonte: Elaborado pelo autor (2025)*

### 4.1.2 Sprint planning

O desenvolvimento de projeto é pensado para ser dividido em sprints - períodos de tempo onde um ou mais requisitos (funcionais ou não funcionais) são escolhidos para serem construídos e entregues. Para este projeto, foi adotado um cronograma de 7 meses (março a setembro) com sprints de 4 semanas cada, adaptando a metodologia Scrum ao contexto acadêmico. Esta duração permite maior profundidade no desenvolvimento das funcionalidades complexas do sistema, incluindo integração com IA e desenvolvimento de interfaces responsivas, garantindo qualidade e robustez na entrega final. É importante destacar que as atividades podem ocorrer em paralelo, desde que não haja dependências críticas entre elas, otimizando o tempo de desenvolvimento e permitindo feedback contínuo durante o processo.

A seguir são apresentadas a divisão dos requisitos em sprints e o tempo estimado para cada um. Também é apresentada no quadro 14 a visualização geral do Sprint Planning em um gráfico de Gantt e na Figura 13 o diagrama de Gantt visual com as atividades paralelas.

**Sprint 1 (Março) - Fundação e Autenticação (4 semanas)**
Estruturação completa do banco de dados (modelagem, migrações e relacionamentos), implementação do sistema de autenticação JWT com gestão de usuários e papéis (CRUD), e desenvolvimento das interfaces de login e gestão. Inclui testes e estabilização contínuos.

**Sprint 2 (Abril) - Gestão de Colaboradores e Condomínios (4 semanas)**
Desenvolvimento dos módulos de gestão de colaboradores e condomínios (CRUDs e modelos), implementação do sistema de escalas mensais com lógica de alocação, e integração entre os módulos. Foco em testes de integração para garantir a consistência dos dados.

**Sprint 3 (Maio) - Gestão de Rondas (4 semanas)**
Implementação do sistema de gestão de rondas, incluindo a programação, execução com checkpoints via geolocalização, e o desenvolvimento da interface de acompanhamento. Geração de relatórios básicos, com refinamentos e documentação contínua ao longo do sprint.

**Sprint 4 (Junho) - Gestão de Ocorrências (4 semanas)**
Desenvolvimento do módulo de ocorrências (CRUD e modelo) e implementação do workflow de atendimento de ponta a ponta, incluindo o sistema de notificações integrado. Foco em testes de integração do workflow e documentação dos processos.

**Sprint 5 (Julho) - Inteligência Artificial (4 semanas)**
Integração com a API do Google Gemini para classificação automática de ocorrências, incluindo o tratamento e refinamento dos resultados. Desenvolvimento da funcionalidade de geração de insights e análises preditivas. Ciclos de testes e otimização de performance da IA.

**Sprint 6 (Agosto) - Relatórios e Analytics (4 semanas)**
Construção do sistema de relatórios avançados e dashboards analíticos. Preparação do ambiente de produção e execução do processo de deploy. Realização dos testes finais de sistema (homologação), criação da documentação técnica e aplicação de ajustes.

**Sprint 7 (Setembro) - Finalização e Entrega (4 semanas)**
Execução dos testes de aceitação do usuário (UAT), aplicação das correções finais, e consolidação de toda a documentação do projeto. Preparação do material para a apresentação, defesa do TCC, e implementação de ajustes pós-banca. Encerramento formal e entrega da versão final do projeto.

**Quadro 14 - Sprint Planning por Sprints**

| Sprint | Mês | Semanas | Foco Principal | Duração |
|--------|-----|---------|----------------|---------|
| Sprint 1 | Março | 1-4 | Fundação e Autenticação | 4 semanas |
| Sprint 2 | Abril | 5-8 | Gestão de Colaboradores e Condomínios | 4 semanas |
| Sprint 3 | Maio | 9-12 | Gestão de Rondas | 4 semanas |
| Sprint 4 | Junho | 13-16 | Gestão de Ocorrências | 4 semanas |
| Sprint 5 | Julho | 17-20 | Inteligência Artificial | 4 semanas |
| Sprint 6 | Agosto | 21-24 | Relatórios e Analytics | 4 semanas |
| Sprint 7 | Setembro | 25-28 | Finalização e Entrega | 4 semanas |

*Fonte: Elaborado pelo autor (2025)*

### 4.1.3 Sprint goal

O Sprint Goal é uma declaração de propósito para cada sprint, orientando o que precisa ser alcançado durante o ciclo de desenvolvimento. Essa meta deve alinhar os esforços do desenvolvedor e servir como um critério para avaliar o sucesso do sprint. Os objetivos devem ser revisados e ajustados conforme necessário, com base em feedback e resultados dos sprints anteriores.

A seguir, são listados os sprints e seus respectivos objetivos.

**Sprint 1 (Março) - Fundação e Autenticação**
Estruturação completa do banco de dados (modelagem, migrações e relacionamentos), implementação do sistema de autenticação JWT com gestão de usuários e papéis (CRUD), e desenvolvimento das interfaces de login e gestão. Inclui testes e estabilização contínuos.

**Sprint 2 (Abril) - Gestão de Colaboradores e Condomínios**
Desenvolvimento dos módulos de gestão de colaboradores e condomínios (CRUDs e modelos), implementação do sistema de escalas mensais com lógica de alocação, e integração entre os módulos. Foco em testes de integração para garantir a consistência dos dados.

**Sprint 3 (Maio) - Gestão de Rondas**
Implementação do sistema de gestão de rondas, incluindo a programação, execução com checkpoints via geolocalização, e o desenvolvimento da interface de acompanhamento. Geração de relatórios básicos, com refinamentos e documentação contínua ao longo do sprint.

**Sprint 4 (Junho) - Gestão de Ocorrências**
Desenvolvimento do módulo de ocorrências (CRUD e modelo) e implementação do workflow de atendimento de ponta a ponta, incluindo o sistema de notificações integrado. Foco em testes de integração do workflow e documentação dos processos.

**Sprint 5 (Julho) - Inteligência Artificial**
Integração com a API do Google Gemini para classificação automática de ocorrências, incluindo o tratamento e refinamento dos resultados. Desenvolvimento da funcionalidade de geração de insights e análises preditivas. Ciclos de testes e otimização de performance da IA.

**Sprint 6 (Agosto) - Relatórios e Analytics**
Construção do sistema de relatórios avançados e dashboards analíticos. Preparação do ambiente de produção e execução do processo de deploy. Realização dos testes finais de sistema (homologação), criação da documentação técnica e aplicação de ajustes.

**Sprint 7 (Setembro) - Finalização e Entrega**
Execução dos testes de aceitação do usuário (UAT), aplicação das correções finais, e consolidação de toda a documentação do projeto. Preparação do material para a apresentação, defesa do TCC, e implementação de ajustes pós-banca. Encerramento formal e entrega da versão final do projeto.

### 4.1.4 Daily Scrum

As reuniões de Daily Scrum são fundamentais para garantir a comunicação eficaz entre o desenvolvedor e o orientador, permitindo ajustes rápidos e alinhamento sobre o progresso do projeto. No contexto deste trabalho, as reuniões com o orientador desempenham um papel similar, fornecendo feedback e orientação contínua.

A seguir é apresentado a Tabela 15, que incorpora a Tabela 14 (Sprint Planning) às datas das reuniões com o orientador para validação e homologação dos Goals.

**Quadro 15 - Cronograma de Sprints e Reuniões de Validação**

| Sprint | Mês | Semanas | Foco Principal | Reunião de Validação |
|--------|-----|---------|----------------|---------------------|
| Sprint 1 | Março | 1-4 | Fundação e Autenticação | 28/03 |
| Sprint 2 | Abril | 5-8 | Gestão de Colaboradores e Condomínios | 28/04 |
| Sprint 3 | Maio | 9-12 | Gestão de Rondas | 28/05 |
| Sprint 4 | Junho | 13-16 | Gestão de Ocorrências | 28/06 |
| Sprint 5 | Julho | 17-20 | Inteligência Artificial | 28/07 |
| Sprint 6 | Agosto | 21-24 | Relatórios e Analytics | 28/08 |
| Sprint 7 | Setembro | 25-28 | Finalização e Entrega | 28/09 |

*Fonte: Elaborado pelo autor (2025)*

Para melhor visualização temporal do cronograma de desenvolvimento, foi elaborado um diagrama de Gantt que representa graficamente a distribuição dos sprints ao longo dos sete meses de projeto. Este diagrama permite visualizar a sequência e duração de cada sprint, facilitando o acompanhamento do progresso e identificação de marcos importantes do desenvolvimento.

**Figura 13 - Diagrama de Gantt Simplificado por Sprints**

```
Sprints                       Mar  Abr  Mai  Jun  Jul  Ago  Set
                            1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4
                            █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █
Sprint 1 - Fundação e       ████
Autenticação

Sprint 2 - Gestão de        ████████
Colaboradores e Condomínios

Sprint 3 - Gestão de Rondas ████████████

Sprint 4 - Gestão de        ████████████████
Ocorrências

Sprint 5 - Inteligência     ████████████████████
Artificial

Sprint 6 - Relatórios e     ████████████████████████
Analytics

Sprint 7 - Finalização e    ████████████████████████████
Entrega

Legenda:
███ = Duração do Sprint (4 semanas cada)
```

*Fonte: Elaborado pelo autor (2025)*

## 4.2 Diagramações

### 4.2.1 Casos de uso

Os casos de uso descrevem as interações entre atores (usuários ou sistemas externos) e o sistema com o objetivo de atingir um objetivo específico auxiliando a compreensão de como o sistema deve se comportar em diferentes situações, identificando funcionalidades, regras de negócio e possíveis fluxos de execução. Para este projeto foram determinados quatro atores (Administrador, Supervisor, Agente de Segurança e Sistema de IA) e seis casos de uso.

O diagrama apresentado a seguir ilustra a estrutura hierárquica dos atores e suas respectivas interações com o sistema. Cada ator possui diferentes níveis de acesso e responsabilidades, desde operações básicas até funcionalidades administrativas avançadas, incluindo a integração com inteligência artificial para processamento automatizado.

**Figura 14 - Diagrama de Caso de Uso**

```
┌─────────────────┐
│   Administrador │
└─────────┬───────┘
          │
          │ ┌─────────────────┐
          │ │   Supervisor    │
          │ └─────────┬───────┘
          │           │
          │           │ ┌─────────────────┐
          │           │ │ Agente Segurança│
          │           │ └─────────┬───────┘
          │           │           │
          │           │           │ ┌─────────────────┐
          │           │           │ │  Sistema de IA  │
          │           │           │ └─────────┬───────┘
          │           │           │           │
          ▼           ▼           ▼           ▼
    ┌─────────────────────────────────────────────────┐
    │           Sistema de Gestão de Segurança        │
    │                                                 │
    │  ┌─────────────┐  ┌─────────────┐  ┌──────────┐ │
    │  │ Autenticar  │  │ Executar    │  │ Registrar│ │
    │  │ Usuário     │  │ Ronda       │  │ Ocorrência│ │
    │  └─────────────┘  └─────────────┘  └──────────┘ │
    │                                                 │
    │  ┌─────────────┐  ┌─────────────┐  ┌──────────┐ │
    │  │ Gerenciar   │  │ Classificar │  │ Gerar    │ │
    │  │ Usuários    │  │ com IA      │  │ Relatórios│ │
    │  └─────────────┘  └─────────────┘  └──────────┘ │
    └─────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

A seguir, cada um dos itens do diagrama de caso de uso é detalhado:

- **Ator "Administrador"**: Interage com o sistema para gerenciamento completo, incluindo usuários, configurações e relatórios gerenciais.
- **Ator "Supervisor"**: Supervisiona operações, analisa relatórios e gerencia escalas de colaboradores.
- **Ator "Agente de Segurança"**: Executa rondas, registra ocorrências e utiliza o sistema no dia a dia operacional.
- **Ator "Sistema de IA"**: Classifica automaticamente ocorrências e gera insights de segurança.
- **Caso de Uso "Autenticar Usuário"**: Permite que qualquer usuário se autentique no sistema com controle de acesso baseado em papéis.
- **Caso de Uso "Executar Ronda"**: Permite ao agente executar rondas programadas com sistema de checkpoints e registro de atividades.
- **Caso de Uso "Registrar Ocorrência"**: Permite ao agente registrar incidentes com classificação automática.
- **Caso de Uso "Gerenciar Usuários"**: Permite ao administrador gerenciar usuários, papéis e permissões.
- **Caso de Uso "Classificar com IA"**: Sistema automático de classificação de ocorrências usando Google Gemini.
- **Caso de Uso "Gerar Relatórios"**: Permite gerar relatórios detalhados de rondas, ocorrências e análises.

### 4.2.2 Diagrama de componentes

Esse diagrama apresenta a estrutura física e lógica de um sistema em termos de componentes, suas interfaces e dependências possibilitando a visualização e organização dos relacionamentos entre as partes modulares de um sistema de software.

A arquitetura do sistema foi projetada seguindo uma abordagem em camadas, onde cada componente possui responsabilidades bem definidas. O frontend responsivo comunica-se com o backend através de APIs RESTful, que por sua vez interage com o banco de dados PostgreSQL e serviços externos como o Google Gemini para funcionalidades de IA. Esta estruturação facilita a manutenção, escalabilidade e evolução do sistema.

**Figura 15 - Diagrama de Componentes**

```
┌─────────────────────────────────────────────────────────────────┐
│                        Frontend (Bootstrap)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ Templates   │  │ JavaScript  │  │ CSS/UI      │            │
│  │ Jinja2      │  │ Interativo  │  │ Responsivo  │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────┬───────────────────────────────────────────┘
                      │ HTTP/HTTPS
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Backend (Flask)                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ Blueprints  │  │ Services    │  │ Middleware  │            │
│  │ (Routes)    │  │ (Business)  │  │ (Security)  │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────┬───────────────────────────────────────────┘
                      │ SQLAlchemy ORM
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Database (PostgreSQL)                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ Models      │  │ Migrations  │  │ Views       │            │
│  │ (Tables)    │  │ (Alembic)   │  │ Materialized│            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    External Services                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ Google      │  │ Email       │  │ File        │            │
│  │ Gemini AI   │  │ Services    │  │ Storage     │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

O detalhamento dos componentes apresentados na Figura 2 é descrito a seguir:

- **Frontend (Bootstrap)**
  - Descrição: Interface de usuário responsiva para interação e visualização de dados.
  - Responsabilidades: Exibir dashboards, formulários de rondas e ocorrências, relatórios interativos.

- **Backend (Flask)**
  - Descrição: Processamento de lógica de negócios, autenticação e comunicação com banco de dados.
  - Responsabilidades: Autenticar usuários, processar dados de rondas e ocorrências, gerar APIs RESTful.

- **Database (PostgreSQL)**
  - Descrição: Armazenamento de dados de usuários, rondas, ocorrências e colaboradores.
  - Responsabilidades: Persistir dados de segurança, armazenar logs de auditoria, views materializadas.

- **External Services**
  - Descrição: Serviços externos para IA, comunicação e armazenamento.
  - Responsabilidades: Classificação automática com Gemini, envio de emails, armazenamento de arquivos.

### 4.2.3 Diagrama de tabelas e relacionamentos (DTR)

Trata-se de uma representação visual que descreve a estrutura do banco de dados relacional utilizado neste projeto (incluindo suas tabelas, atributos e relacionamentos) objetivando apresentar o planejamento da documentação do banco de dados para posterior implementação.

O modelo de dados foi estruturado para suportar todas as funcionalidades do sistema de gestão de segurança, incluindo controle de usuários, gestão de rondas, registro de ocorrências e relacionamentos com condomínios e colaboradores. O banco conta com 18 tabelas principais, 4 views materializadas para otimização de consultas e 2 tabelas de relacionamento muitos-para-muitos, garantindo integridade referencial e performance adequada para as operações do sistema.

**Figura 16 - Diagrama de Tabelas e Relacionamentos (Visão Simplificada)**

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│     User        │     │    Ronda        │     │   Ocorrencia    │
│                 │     │                 │     │                 │
│ • id (PK)       │────▶│ • id (PK)       │────▶│ • id (PK)       │
│ • username      │     │ • data_inicio   │     │ • relatorio     │
│ • email         │     │ • data_fim      │     │ • data_ocorrencia│
│ • role          │     │ • condominio_id │     │ • status        │
│ • is_admin      │     │ • user_id       │     │ • tipo_id       │
│ • is_supervisor │     │ • supervisor_id │     │ • condominio_id │
└─────────┬───────┘     └─────────┬───────┘     └─────────┬───────┘
          │                       │                       │
          │ 1:N                   │ 1:N                   │ 1:N
          │                       │                       │
          ▼                       ▼                       ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Colaborador    │     │   Condominio    │     │ OcorrenciaTipo  │
│                 │     │                 │     │                 │
│ • id (PK)       │     │ • id (PK)       │     │ • id (PK)       │
│ • nome          │     │ • nome          │     │ • nome          │
│ • cpf           │     │ • endereco      │     │ • descricao     │
│ • telefone      │     │ • contato       │     │                 │
│ • email         │     │ • ativo         │     │                 │
│ • cargo         │     │                 │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Tabelas de Apoio e Views                     │
│                                                                 │
│ •    EscalaMensal       • LoginHistory        • UserOnline      │
│ • OrgaoPublico          • ProcessingHistory   • Logradouro      │
│ • VW_RondasDetalhadas   • VW_OcorrenciasDetalhadas            │
│ • VW_Colaboradores      • VW_Logradouros      • GeminiUsage     │
│                                                                 │
│ Total: 18 tabelas | 4 Views Materializadas | 2 Tabelas N:M     │
└─────────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

## 4.3 Programação e testes

### 4.3.1 Programação

A seguir são apresentados os principais trechos de código fonte (mais representativos) desenvolvidos durante o projeto, ilustrando a estruturação lógica e organização adotada na implementação do sistema, onde é possível visualizar como o código foi organizado próximo ao padrão arquitetural MVC (Model-View-Controller), evidenciando a separação entre as camadas de interface, lógica de negócios e persistência dos dados. Além disso, são destacadas partes do código responsáveis pela integração com inteligência artificial e a rotina responsável por receber, tratar e armazenar os dados coletados pelos agentes de segurança.

Para demonstrar a organização estrutural do projeto, apresenta-se inicialmente a árvore de diretórios do backend, que ilustra como o código foi distribuído seguindo o padrão MVC. Esta estrutura facilita a manutenção, permite escalabilidade e proporciona clara separação de responsabilidades entre as diferentes camadas da aplicação.

**Figura 17 - Estrutura de código do Backend (Flask)**

```
backend/
├── app/
│   ├── __init__.py
│   ├── models/
│   │   ├── user.py
│   │   ├── ronda.py
│   │   ├── ocorrencia.py
│   │   └── colaborador.py
│   ├── blueprints/
│   │   ├── auth/
│   │   ├── admin/
│   │   ├── ronda/
│   │   └── ocorrencia/
│   ├── services/
│   │   ├── auth_service.py
│   │   ├── ronda_service.py
│   │   └── ai_service.py
│   └── utils/
│       ├── classificador.py
│       └── date_utils.py
├── config.py
└── run.py
```

*Fonte: Elaborado pelo autor (2025)*

Complementando a estrutura do backend, o frontend foi organizado de forma modular para facilitar a manutenção e permitir a reutilização de componentes. A estrutura apresentada a seguir mostra a separação entre recursos estáticos (CSS, JavaScript e imagens) e templates HTML, seguindo as melhores práticas de desenvolvimento web para garantir responsividade e interatividade adequadas.

**Figura 18 - Estrutura de código do Frontend**

```
frontend/
├── static/
│   ├── css/
│   │   ├── style.css              # Estilos principais
│   │   ├── login.css              # Estilos de autenticação
│   │   ├── modern-design.css      # Design moderno
│   │   ├── mobile-responsive.css  # Responsividade
│   │   ├── help-system.css        # Sistema de ajuda
│   │   └── feedback-components.css # Componentes de feedback
│   ├── js/
│   │   ├── script.js              # JavaScript principal
│   │   ├── help-system.js         # Sistema de ajuda
│   │   ├── dashboard_tooltips.js  # Tooltips do dashboard
│   │   ├── date-config.js         # Configuração de datas
│   │   └── index_page/            # Módulos da página principal
│   │       ├── main.js            # Lógica principal
│   │       ├── apiService.js      # Comunicação com API
│   │       ├── uiHandlers.js      # Manipulação da UI
│   │       ├── reportLogic.js     # Lógica de relatórios
│   │       └── config.js          # Configurações
│   └── images/
│       ├── logo.png               # Logo principal
│       ├── logo_master.png        # Logo master
│       └── login-background.jpg   # Background de login
└── templates/
    ├── base.html                  # Template base
    ├── index.html                 # Página principal
    ├── auth/                      # Autenticação
    │   ├── login.html
    │   └── register.html
    ├── admin/                     # Painel administrativo
    │   ├── dashboard.html
    │   ├── users.html
    │   ├── ferramentas.html
    │   └── [outros templates admin]
    ├── ronda/                     # Gestão de rondas
    │   ├── list.html
    │   ├── details.html
    │   └── relatorio.html
    ├── ocorrencia/                # Gestão de ocorrências
    │   ├── list.html
    │   ├── form_direto.html
    │   └── details.html
    └── gerenciamento/             # Gestão geral
        ├── tipos_ocorrencia.html
        └── orgaos_publicos.html
```

*Fonte: Elaborado pelo autor (2025)*

Para demonstrar a implementação prática do padrão MVC, apresenta-se o modelo User, que representa a camada de persistência de dados. Este modelo implementa todas as funcionalidades relacionadas ao gerenciamento de usuários, incluindo autenticação segura, controle de papéis e relacionamentos com outras entidades do sistema. O uso do SQLAlchemy como ORM facilita a manipulação dos dados e garante a integridade referencial.

**Figura 19 - Código do modelo User**

```python
from app import db
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timezone

class User(UserMixin, db.Model):
    __tablename__ = "user"
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(20), nullable=False, default='agente', index=True)
    is_active = db.Column(db.Boolean, default=True, nullable=False)
    is_admin = db.Column(db.Boolean, default=False, nullable=False)
    is_supervisor = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))
    
    # Relacionamentos
    rondas_criadas = db.relationship("Ronda", foreign_keys="Ronda.user_id", back_populates="criador")
    rondas_supervisionadas = db.relationship("Ronda", foreign_keys="Ronda.supervisor_id", back_populates="supervisor")
    ocorrencias_registradas = db.relationship("Ocorrencia", foreign_keys="Ocorrencia.registrado_por_user_id", back_populates="registrado_por")
    ocorrencias_supervisionadas = db.relationship("Ocorrencia", foreign_keys="Ocorrencia.supervisor_id", back_populates="supervisor")
    
    def set_password(self, password):
        """Define a senha do usuário com hash seguro"""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """Verifica se a senha fornecida está correta"""
        return check_password_hash(self.password_hash, password)
    
    def to_dict(self):
        """Converte o usuário para dicionário para serialização JSON"""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'role': self.role,
            'is_active': self.is_active,
            'is_admin': self.is_admin,
            'is_supervisor': self.is_supervisor,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }
    
    def __repr__(self):
        return f'<User {self.username}>'
```

*Fonte: Elaborado pelo autor (2025)*

Outro modelo fundamental do sistema é a classe Ocorrencia, que gerencia todos os dados relacionados aos incidentes de segurança registrados. Este modelo demonstra a complexidade dos relacionamentos no sistema, incluindo vínculos com usuários, condomínios, tipos de ocorrência e órgãos públicos, além de implementar funcionalidades para rastreamento temporal e controle de status.

**Figura 20 - Código do modelo Ocorrencia**

```python
from app import db
from sqlalchemy import func
from datetime import datetime, timezone

class Ocorrencia(db.Model):
    """Modelo de ocorrência (incidente registrado)."""
    __tablename__ = "ocorrencia"
    
    id = db.Column(db.Integer, primary_key=True)
    relatorio_final = db.Column(db.Text, nullable=False)
    data_hora_ocorrencia = db.Column(
        db.DateTime(timezone=True),
        nullable=False,
        server_default=func.now(),
        index=True,
    )
    turno = db.Column(db.String(50), nullable=True)
    status = db.Column(db.String(50), nullable=False, default="Registrada", index=True)
    endereco_especifico = db.Column(db.String(255), nullable=True)
    logradouro_id = db.Column(db.Integer, db.ForeignKey("logradouro.id"), nullable=True)
    data_criacao = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    data_modificacao = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))
    condominio_id = db.Column(db.Integer, db.ForeignKey("condominio.id"), nullable=True, index=True)
    ocorrencia_tipo_id = db.Column(db.Integer, db.ForeignKey("ocorrencia_tipo.id"), nullable=False, index=True)
    registrado_por_user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    supervisor_id = db.Column(db.Integer, db.ForeignKey("user.id", name="fk_ocorrencia_supervisor_id"), nullable=True, index=True)
    
    # Relacionamentos
    logradouro = db.relationship("Logradouro", backref="ocorrencias")
    condominio = db.relationship("Condominio", backref="ocorrencias")
    tipo = db.relationship("OcorrenciaTipo", backref="ocorrencias")
    registrado_por = db.relationship("User", foreign_keys=[registrado_por_user_id], back_populates="ocorrencias_registradas")
    supervisor = db.relationship("User", foreign_keys=[supervisor_id], back_populates="ocorrencias_supervisionadas")
    
    orgaos_acionados = db.relationship(
        "OrgaoPublico",
        secondary=ocorrencia_orgaos,
        lazy="subquery",
        backref=db.backref("ocorrencias_acionadas", lazy=True),
    )
    colaboradores_envolvidos = db.relationship(
        "Colaborador",
        secondary=ocorrencia_colaboradores,
        lazy="subquery",
        backref=db.backref("ocorrencias_atendidas", lazy=True),
    )
    
    def __repr__(self) -> str:
        tipo_nome = self.tipo.nome if self.tipo else "N/A"
        data_str = self.data_hora_ocorrencia.strftime('%d/%m/%Y %H:%M')
        cond_nome = self.condominio.nome if self.condominio else "Sem Condomínio"
        return f'<Ocorrencia {self.id} - {tipo_nome} em {data_str} ({cond_nome})>'
```

*Fonte: Elaborado pelo autor (2025)*

Representando a camada de controle do padrão MVC, as rotas de autenticação implementam a lógica de segurança do sistema. Este código demonstra como são tratados os processos de login, validação de credenciais, geração de tokens JWT e controle de sessões. A implementação inclui limitação de tentativas de login e suporte tanto para interfaces web quanto para APIs REST.

**Figura 21 - Código das rotas de autenticação**

```python
from flask import Blueprint, request, jsonify, session, redirect, url_for, flash
from flask_login import current_user, login_user, logout_user
from flask_jwt_extended import create_access_token
from app import db, limiter, csrf
from app.models import User

auth_bp = Blueprint("auth", __name__)

@auth_bp.route("/login", methods=["GET", "POST"])
@limiter.limit("10 per minute")
def login():
    """Rota de login de usuário."""
    if current_user.is_authenticated:
        return redirect(url_for("main.index"))

    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        login_success = False

        if user and user.check_password(form.password.data):
            if not user.is_approved:
                flash("Conta ainda não aprovada.", "warning")
                return redirect(url_for("auth.login"))

            login_user(user, remember=form.remember.data)
            session.permanent = True
            session['last_seen_utc'] = datetime.now(timezone.utc).isoformat()
            login_success = True
            user.last_login = datetime.now(timezone.utc)
            db.session.commit()
            flash(f"Bem-vindo, {user.username}!", "success")
        else:
            flash("Login falhou. Verifique email e senha.", "danger")

        if login_success:
            next_page = request.args.get("next")
            if not next_page or urlsplit(next_page).netloc != "":
                next_page = url_for("main.index")
            return redirect(next_page)

    return render_template("auth/login.html", title="Login", form=form)

@auth_bp.route("/api/login", methods=["POST", "OPTIONS"])
@cross_origin()
@csrf.exempt
def api_login():
    """Rota de login para API com JWT."""
    data = request.get_json() or {}
    email = data.get("email")
    password = data.get("password")
    
    if not email or not password:
        return jsonify({"success": False, "message": "Email e senha são obrigatórios."}), 400
    
    user = User.query.filter_by(email=email).first()
    if user and user.check_password(password):
        if not user.is_approved:
            return jsonify({"success": False, "message": "Conta ainda não aprovada."}), 403
        
        login_user(user)
        session.permanent = True
        session['last_seen_utc'] = datetime.now(timezone.utc).isoformat()
        user.last_login = datetime.now(timezone.utc)
        db.session.commit()
        
        token = create_access_token(identity=user.id)
        return jsonify({
            "data": {
                "token": token,
                "user": {
                    "id": user.id,
                    "username": user.username,
                    "email": user.email,
                    "is_admin": user.is_admin
                }
            },
            "message": f"Bem-vindo, {user.username}!",
            "success": True
        })
    
    return jsonify({"success": False, "message": "Credenciais inválidas."}), 401
```

*Fonte: Elaborado pelo autor (2025)*

Uma das principais inovações do sistema é a integração com inteligência artificial através do Google Gemini. O serviço base de IA apresentado implementa funcionalidades avançadas como cache inteligente, fallback automático entre chaves de API, controle de rate limiting e tratamento robusto de erros. Esta implementação garante alta disponibilidade e performance nas operações de processamento de texto.

**Figura 22 - Código do serviço base de IA**

```python
# app/services/base_generative_service.py
import hashlib
import logging
import os
import time
from datetime import datetime, timedelta
from flask import request, current_app
from flask_login import current_user

import google.generativeai as genai

from app import cache, db
from app.models.gemini_usage import GeminiUsageLog

class BaseGenerativeService:
    def __init__(self, model_name="gemini-1.5-flash-latest"):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.model = None
        self._google_api_key = None
        
        # Rate limiting para APIs Gemini
        self._api_usage = {
            "GOOGLE_API_KEY_1": {"last_used": None, "daily_count": 0, "last_reset": None},
            "GOOGLE_API_KEY_2": {"last_used": None, "daily_count": 0, "last_reset": None}
        }
        
        # Limites de rate (ajuste conforme necessário)
        self._rate_limits = {
            "requests_per_day": 45,  # Deixe margem de segurança
            "min_interval_seconds": 2  # Intervalo mínimo entre requisições
        }

        try:
            # Tenta usar GOOGLE_API_KEY_1 primeiro, depois GOOGLE_API_KEY como fallback
            self._google_api_key = os.getenv("GOOGLE_API_KEY_1") or os.getenv("GOOGLE_API_KEY")
            if not self._google_api_key:
                self.logger.error(
                    "API Key do Google (GOOGLE_API_KEY_1 ou GOOGLE_API_KEY) não encontrada nas variáveis de ambiente."
                )
                raise RuntimeError(
                    "API Key do Google (GOOGLE_API_KEY_1 ou GOOGLE_API_KEY) não configurada nas variáveis de ambiente."
                )

            genai.configure(api_key=self._google_api_key)
            self.logger.info(
                "Configuração da API Key do Google bem-sucedida para o serviço."
            )

            generation_config = {
                "temperature": 0.7,
                "top_p": 0.95,
                "top_k": 64,
                "max_output_tokens": 8192,
                "response_mime_type": "text/plain",
            }
            safety_settings = [
                {
                    "category": "HARM_CATEGORY_HARASSMENT",
                    "threshold": "BLOCK_MEDIUM_AND_ABOVE",
                },
                {
                    "category": "HARM_CATEGORY_HATE_SPEECH",
                    "threshold": "BLOCK_MEDIUM_AND_ABOVE",
                },
                {
                    "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    "threshold": "BLOCK_MEDIUM_AND_ABOVE",
                },
                {
                    "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                    "threshold": "BLOCK_MEDIUM_AND_ABOVE",
                },
            ]

            self.model = genai.GenerativeModel(
                model_name=model_name,
                safety_settings=safety_settings,
                generation_config=generation_config,
            )
            self.logger.info(
                f"Modelo Gemini '{self.model.model_name}' inicializado com sucesso para {self.__class__.__name__}."
            )

        except RuntimeError as rte:
            self.logger.critical(
                f"Falha na inicialização do serviço (configuração da API): {rte}"
            )
            raise
        except Exception as e:
            self.logger.critical(
                f"Falha catastrófica na inicialização do serviço ({self.__class__.__name__}): {e}",
                exc_info=True,
            )
            self.model = None
            raise RuntimeError(
                f"Falha catastrófica na inicialização do serviço de IA: {e}"
            )

    def _generate_cache_key(self, prompt_final: str) -> str:
        """Gera chave de cache estável baseada no conteúdo do prompt"""
        content_hash = hashlib.md5(prompt_final.encode('utf-8')).hexdigest()
        cache_key = f"gemini_{self.__class__.__name__}_{content_hash}"
        return cache_key

    @cache.memoize(timeout=3600)  # Cache por 1 hora
    def _call_generative_model(self, prompt_final: str) -> str:
        """Chama o modelo generativo com fallback automático entre API keys"""
        import google.generativeai as genai
        import os
        
        # Log detalhado do cache
        cache_key = self._generate_cache_key(prompt_final)
        self.logger.info(f"🚀 CACHE MISS - Nova consulta para chave: {cache_key[:16]}...")
        self.logger.info(f"📝 Prompt (primeiros 100 chars): {prompt_final[:100]}...")
        
        if not isinstance(prompt_final, str) or not prompt_final.strip():
            self.logger.warning("Prompt final está vazio ou não é uma string.")
            raise ValueError("Prompt final para a IA não pode ser vazio.")

        # Configuração das API Keys para fallback automático
        api_keys = [
            ("GOOGLE_API_KEY_1", os.environ.get("GOOGLE_API_KEY_1")),
            ("GOOGLE_API_KEY_2", os.environ.get("GOOGLE_API_KEY_2"))
        ]
        last_exception = None
        
        for api_key_name, api_key in api_keys:
            if not api_key:
                continue
                
            try:
                genai.configure(api_key=api_key)
                model = genai.GenerativeModel("gemini-1.5-flash")
                response = model.generate_content(prompt_final)
                
                if response and response.text:
                    self.logger.info(f"✅ Resposta obtida com sucesso usando {api_key_name}")
                    return response.text.strip()
                else:
                    self.logger.warning(f"⚠️ Resposta vazia de {api_key_name}")
                    
            except Exception as e:
                last_exception = e
                self.logger.warning(f"❌ Falha com {api_key_name}: {e}")
                continue
        
        # Se chegou aqui, todas as API keys falharam
        error_msg = f"Todas as API Keys falharam. Último erro: {last_exception}"
        self.logger.error(error_msg)
        raise RuntimeError(error_msg)
```

*Fonte: Elaborado pelo autor (2025)*

Para facilitar o processo de desenvolvimento e testes, foi implementado um sistema de comandos CLI que permite a inicialização automática do banco de dados. O comando apresentado cria usuários administrativos padrão, facilitando o setup inicial do ambiente de desenvolvimento. Esta abordagem automatizada reduz erros manuais e acelera o processo de configuração do sistema.

**Figura 23 - Código do comando de inicialização do banco**

```python
# backend/app/commands/seed.py
import logging
import os
import click
from flask.cli import with_appcontext
from app.models import User
from app import db

logger = logging.getLogger(__name__)

@click.command("seed-db")
@with_appcontext
def seed_db_command():
    """
    Cria usuários administradores e supervisores padrão para desenvolvimento.
    AVISO: Nunca use este comando em produção! As senhas são fracas e conhecidas.
    Para produção, crie usuários manualmente ou implemente um fluxo seguro.
    """
    default_users = [
        {
            "username": "Luis Royo",
            "email": "luisroyo25@gmail.com",
            "is_admin": True,
            "is_supervisor": True,
            "is_approved": True,
            "password": os.getenv("ADMIN_PASSWORD", "dev123"),
        }
    ]
    
    for user_data in default_users:
        try:
            user_exists = User.query.filter_by(email=user_data["email"]).first()
            if not user_exists:
                new_user = User(
                    username=user_data["username"],
                    email=user_data["email"],
                    is_admin=user_data.get("is_admin", False),
                    is_supervisor=user_data.get("is_supervisor", False),
                    is_approved=user_data.get("is_approved", True),
                )
                new_user.set_password(user_data["password"])
                db.session.add(new_user)
                logger.info(f"Usuário '{user_data['username']}' criado com sucesso.")
                click.echo(f"Usuário '{user_data['username']}' criado com sucesso.")
            else:
                if user_data.get("is_supervisor") and not user_exists.is_supervisor:
                    user_exists.is_supervisor = True
                    logger.info(
                        f"Usuário '{user_data['username']}' atualizado para supervisor."
                    )
                    click.echo(
                        f"Usuário '{user_data['username']}' atualizado para supervisor."
                    )
                else:
                    click.echo(f"Usuário '{user_data['username']}' já existe.")
        except Exception as e:
            db.session.rollback()
            logger.error(
                f"Falha ao criar/atualizar usuário '{user_data['username']}': {e}",
                exc_info=True,
            )
            click.echo(f"Erro ao processar usuário '{user_data['username']}': {e}")
            return
    
    db.session.commit()
    logger.info("Comando de inicialização do banco de dados concluído.")
    click.echo("Comando de inicialização do banco de dados concluído.")
```

*Fonte: Elaborado pelo autor (2025)*

O sistema utiliza blueprints do Flask para organizar as rotas de forma modular. O blueprint de autenticação apresentado implementa todas as funcionalidades relacionadas ao ciclo de vida do usuário, incluindo registro, login, logout e validação de tokens. Esta estrutura modular facilita a manutenção e permite a reutilização de código em diferentes contextos da aplicação.

**Figura 24 - Código do blueprint de autenticação**

```python
# app/blueprints/auth/routes.py
import jwt
from datetime import datetime, timezone, timedelta
from urllib.parse import urlsplit

from flask import (Blueprint, current_app, flash, redirect, render_template,
                   request, url_for, jsonify, session)
from flask_login import current_user, login_user, logout_user
from flask_cors import cross_origin

from app import db, limiter, csrf
from app.forms import LoginForm, RegistrationForm
from app.models import LoginHistory, User

auth_bp = Blueprint("auth", __name__)

@auth_bp.route("/register", methods=["GET", "POST"])
def register():
    """Rota de registro de novo usuário."""
    if current_user.is_authenticated:
        return redirect(url_for("main.index"))

    form = RegistrationForm()
    if form.validate_on_submit():
        try:
            username = form.username.data or ""
            email = form.email.data or ""
            password = form.password.data or ""
            user = User(username=username, email=email)
            user.set_password(password)
            db.session.add(user)
            db.session.commit()
            flash(
                "Conta criada com sucesso. Aguarde aprovação do administrador.", "info"
            )
            return redirect(url_for("auth.login"))
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(
                f"Erro ao registrar usuário {form.username.data}: {e}"
            )
            flash("Erro ao criar a conta. Tente novamente.", "danger")
    return render_template("auth/register.html", title="Registrar", form=form)

@auth_bp.route("/login", methods=["GET", "POST"])
@limiter.limit("10 per minute")
def login():
    """Rota de login de usuário."""
    if current_user.is_authenticated:
        return redirect(url_for("main.index"))

    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        login_success = False

        if user and user.check_password(form.password.data):
            if not user.is_approved:
                flash("Conta ainda não aprovada.", "warning")
                return redirect(url_for("auth.login"))

            login_user(user, remember=form.remember.data)
            session.permanent = True
            session['last_seen_utc'] = datetime.now(timezone.utc).isoformat()
            login_success = True
            user.last_login = datetime.now(timezone.utc)
            db.session.commit()
            flash(f"Bem-vindo, {user.username}!", "success")
        else:
            flash("Login falhou. Verifique email e senha.", "danger")

        if login_success:
            next_page = request.args.get("next")
            if not next_page or urlsplit(next_page).netloc != "":
                next_page = url_for("main.index")
            return redirect(next_page)

    return render_template("auth/login.html", title="Login", form=form)

@auth_bp.route("/logout")
def logout():
    """Rota de logout de usuário."""
    logout_user()
    session.clear()
    flash("Você foi desconectado com sucesso.", "info")
    return redirect(url_for("auth.login"))
```

*Fonte: Elaborado pelo autor (2025)*

Complementando a implementação anterior, esta versão alternativa do blueprint de autenticação demonstra uma abordagem mais focada na separação de responsabilidades, utilizando um serviço dedicado (AuthService) para centralizar a lógica de autenticação. Esta arquitetura facilita os testes unitários e permite maior flexibilidade na implementação de diferentes estratégias de autenticação.

**Figura 25 - Código do blueprint de autenticação (versão alternativa)**

```python
from flask import Blueprint, request, jsonify, session, redirect, url_for, flash
from flask_login import login_user, logout_user, login_required, current_user
from app.services.auth_service import AuthService
from app.models.user import User

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    """Rota de login do sistema"""
    if request.method == 'POST':
        data = request.get_json() if request.is_json else request.form
        username = data.get('username')
        password = data.get('password')
        
        if not username or not password:
            return jsonify({
                'success': False,
                'message': 'Username e senha são obrigatórios'
            }), 400
        
        # Autentica usuário
        result = AuthService.authenticate_user(username, password)
        
        if result['success']:
            user = User.query.filter_by(username=username).first()
            login_user(user)
            
            if request.is_json:
                return jsonify({
                    'success': True,
                    'message': 'Login realizado com sucesso',
                    'user': result['user'],
                    'token': result['token']
                })
            else:
                flash('Login realizado com sucesso!', 'success')
                return redirect(url_for('main.index'))
        else:
            if request.is_json:
                return jsonify({
                    'success': False,
                    'message': result['message']
                }), 401
            else:
                flash(result['message'], 'error')
    
    return render_template('auth/login.html')

@auth_bp.route('/logout')
@login_required
def logout():
    """Rota de logout do sistema"""
    logout_user()
    flash('Logout realizado com sucesso!', 'info')
    return redirect(url_for('auth.login'))

@auth_bp.route('/api/verify-token', methods=['POST'])
def verify_token():
    """Verifica se o token JWT é válido"""
    data = request.get_json()
    token = data.get('token')
    
    if not token:
        return jsonify({'success': False, 'message': 'Token não fornecido'}), 400
    
    payload = AuthService.verify_token(token)
    
    if payload:
        return jsonify({
            'success': True,
            'user': payload
        })
    else:
        return jsonify({
            'success': False,
            'message': 'Token inválido ou expirado'
        }), 401
```

*Fonte: Elaborado pelo autor (2025)*

### 4.3.2 Testes

Com o objetivo de validar o funcionamento do sistema desenvolvido, foi realizada uma série de testes práticos envolvendo todo o fluxo desde a autenticação de usuários até a geração de relatórios. Inicialmente, foi testado o sistema de autenticação com diferentes tipos de usuários (Admin, Supervisor, Agente), comprovado por meio de logs do sistema. Em seguida, foi realizado o teste de execução de rondas e registro de atividades, validado através de dados armazenados no banco. No ambiente web, foram capturadas imagens demonstrando o sistema funcionando corretamente, incluindo dashboards, formulários e relatórios.

Para demonstrar o funcionamento prático do sistema, são apresentadas a seguir as principais interfaces desenvolvidas. A primeira tela mostrada é a interface de login, que representa o ponto de entrada do sistema e implementa os controles de segurança necessários para autenticação dos usuários.

**Figura 26 - Tela de Login**

```
┌─────────────────────────────────────────────────────────────┐
│                Sistema de Gestão de Segurança              │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                                                     │   │
│  │  Usuário: [________________]                        │   │
│  │  Senha:   [________________]                        │   │
│  │                                                     │   │
│  │           [    Entrar    ]                          │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

Após a autenticação, os usuários têm acesso ao dashboard principal do sistema, que centraliza as informações mais relevantes sobre ocorrências de segurança. Esta interface demonstra a capacidade analítica do sistema, oferecendo filtros avançados, visualizações gráficas e métricas em tempo real que auxiliam na tomada de decisões estratégicas.

**Figura 27 - Dashboard de Ocorrências**

```
┌─────────────────────────────────────────────────────────────┐
│  Dashboard de Ocorrências | Filtros | Exportar PDF         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    Filtros                         │   │
│  │  Condomínio: [Todos ▼] Tipo: [Todos ▼]            │   │
│  │  Supervisor: [Todos ▼] Status: [Todos ▼]          │   │
│  │  Mês: [Janeiro ▼] Data Início: [__/__/____]       │   │
│  │  Data Fim: [__/__/____] [Filtrar] [Limpar]        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   Total     │  │  Abertas    │  │  Resolvidas │        │
│  │ Ocorrências │  │             │  │             │        │
│  │             │  │             │  │             │        │
│  │     127     │  │     23      │  │     104     │        │
│  │   Período   │  │  Pendentes  │  │  Concluídas │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Ocorrências por Tipo                  │   │
│  │                                                     │   │
│  │  Roubo/Furto    ████████████ 45% (57 casos)       │   │
│  │  Vandalismo     ████████ 30% (38 casos)           │   │
│  │  Perturbação    ████ 15% (19 casos)               │   │
│  │  Outros         ██ 10% (13 casos)                 │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Ocorrências por Status                │   │
│  │                                                     │   │
│  │  Concluídas    ████████████ 82%                   │   │
│  │  Em Andamento  ███ 15%                            │   │
│  │  Registradas   ██ 3%                              │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

Uma das funcionalidades mais inovadoras do sistema é o analisador de relatórios com inteligência artificial. Esta interface permite que os usuários insiram textos brutos e obtenham versões corrigidas e formatadas automaticamente. A integração com o Google Gemini possibilita melhorias significativas na qualidade dos relatórios, corrigindo gramática, pontuação e estrutura textual.

**Figura 28 - Analisador de Relatórios com IA (Tela Principal)**

```
┌─────────────────────────────────────────────────────────────┐
│  Analisador de Relatórios com IA                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Sistema inteligente que corrige automaticamente relatórios │
│  de segurança, melhorando gramática, pontuação e formatação │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              1. Relatório Bruto                    │   │
│  │                                                     │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │ [hoje as 18:30 eu cheguei no condominio    │   │   │
│  │  │  zermatt e fiz a primeira ronda tudo       │   │   │
│  │  │  normal nao vi nada de suspeito depois     │   │   │
│  │  │  fui pro villa verde e la tambem estava    │   │   │
│  │  │  tudo tranquilo a noite foi calma sem      │   │   │
│  │  │  ocorrencias ate agora]                    │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  │                                                     │   │
│  │  Caracteres: 245 / 12000                           │   │
│  │                                                     │   │
│  │  [Processar com IA] [Limpar Campos]                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │             2. Relatório Corrigido                 │   │
│  │                                                     │   │
│  │  Resultado da Análise:                             │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │ Hoje, às 18:30, cheguei no condomínio       │   │   │
│  │  │ Zermatt e fiz a primeira ronda. Tudo        │   │   │
│  │  │ normal, não vi nada de suspeito. Depois     │   │   │
│  │  │ fui para o Villa Verde e lá também estava   │   │   │
│  │  │ tudo tranquilo. A noite foi calma, sem      │   │   │
│  │  │ ocorrências até agora.                      │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  │                                                     │   │
│  │  [Copiar] [Exportar para Ocorrência]               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Complementando as funcionalidades de IA, o sistema oferece processamento automatizado de registros de ronda. Esta interface permite importar logs de comunicação (como mensagens do WhatsApp) e transformá-los automaticamente em relatórios estruturados, demonstrando a capacidade do sistema de processar dados não estruturados e convertê-los em informações organizadas.

**Figura 29 - Sistema de Registro de Rondas**

```
┌─────────────────────────────────────────────────────────────┐
│  Registrar Ronda                                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Dados da Ronda                         │   │
│  │                                                     │   │
│  │  Condomínio: [Residencial Zermatt ▼]               │   │
│  │  Data do Plantão: [15/01/2025]                     │   │
│  │  Escala: [18h às 06h (Noturno) ▼]                  │   │
│  │  Supervisor: [João Silva ▼]                        │   │
│  │                                                     │   │
│  │  Arquivo WhatsApp (.txt): [Escolher Arquivo]       │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              LOG BRUTO DAS RONDAS                  │   │
│  │                                                     │   │
│  │  [18:11 - Entrei no Zermatt                         │   │
│  │   18:31 - Saí do Zermatt                           │   │
│  │   19:24 - Entrei no Zermatt                        │   │
│  │   19:49 - Saí do Zermatt                           │   │
│  │   21:04 - Entrei no Villa Verde                    │   │
│  │   21:24 - Saí do Villa Verde                       │   │
│  │   22:28 - Entrei no Zermatt                        │   │
│  │   22:48 - Saí do Zermatt]                          │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              RELATÓRIO PROCESSADO                  │   │
│  │                                                     │   │
│  │  Plantão 15/01/2025 (18h às 06h)                   │   │
│  │  Residencial: ZERMATT                              │   │
│  │                                                     │   │
│  │      Início: 18:11 – Término: 18:31 (20 min)      │   │
│  │      Início: 19:24 – Término: 19:49 (25 min)      │   │
│  │      Início: 22:28 – Término: 22:48 (20 min)      │   │
│  │                                                     │   │
│  │  ✅ Total: 3 rondas completas no plantão           │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  [Processar Relatório de Ronda] [Limpar]                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

O registro de ocorrências representa uma das funcionalidades centrais do sistema, integrando classificação automática por inteligência artificial. Esta interface demonstra como o sistema utiliza IA para sugerir categorias de incidentes baseadas na descrição fornecida, agilizando o processo de registro e padronizando a classificação de ocorrências.

**Figura 30 - Tela de Registro de Ocorrências**

```
┌─────────────────────────────────────────────────────────────┐
│  Nova Ocorrência                                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Condomínio: [Residencial Zermatt    ▼]                    │
│  Tipo: [Roubo/Furto ▼] (Classificado por IA)              │
│                                                             │
│  Descrição:                                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ [________________________________]                 │   │
│  │ [________________________________]                 │   │
│  │ [________________________________]                 │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  Gravidade: [Alta ▼]                                       │
│  Responsável: [João Silva ▼]                               │
│                                                             │
│  [Salvar] [Cancelar]                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

O sistema oferece capacidades avançadas de geração de relatórios e análise de dados históricos. Esta interface demonstra como as informações coletadas são transformadas em insights visuais através de gráficos e estatísticas, permitindo aos gestores identificar padrões, tendências e tomar decisões baseadas em dados concretos.

**Figura 31 - Tela de Relatórios**

```
┌─────────────────────────────────────────────────────────────┐
│  Relatórios | Período: [Último Mês ▼]                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Ocorrências por Tipo                   │   │
│  │                                                     │   │
│  │  Roubo/Furto    ████████████ 45%                   │   │
│  │  Vandalismo     ████████ 30%                       │   │
│  │  Perturbação    ████ 15%                           │   │
│  │  Outros         ██ 10%                             │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Rondas por Período                     │   │
│  │                                                     │   │
│  │  Jan ████████████ 120                              │   │
│  │  Fev ██████████ 95                                 │   │
│  │  Mar ████████████ 110                              │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  [Exportar PDF] [Exportar Excel]                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

Expandindo as capacidades de inteligência artificial, o sistema inclui uma interface dedicada à análise avançada de relatórios. Esta funcionalidade demonstra como a IA pode não apenas corrigir textos, mas também extrair informações relevantes, classificar automaticamente o tipo e gravidade de ocorrências, e identificar palavras-chave importantes para análises posteriores.

**Figura 32 - Tela de Análise de Relatórios com IA**

```
┌─────────────────────────────────────────────────────────────┐
│  Analisar Relatório com IA                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Relatório Original                     │   │
│  │                                                     │   │
│  │  [________________________________]                 │   │
│  │  [________________________________]                 │   │
│  │  [________________________________]                 │   │
│  │  [________________________________]                 │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  [Analisar com IA]                                         │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Resultado da Análise                   │   │
│  │                                                     │   │
│  │  Tipo: Roubo/Furto (85% confiança)                 │   │
│  │  Gravidade: Alta                                    │   │
│  │  Palavras-chave: roubo, veículo, estacionamento    │   │
│  │                                                     │   │
│  │  Relatório Formatado:                               │   │
│  │  [________________________________]                 │   │
│  │  [________________________________]                 │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  [Salvar] [Reanalisar] [Cancelar]                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

Para validar o correto funcionamento do sistema, foram realizados testes de persistência de dados no banco PostgreSQL. A figura a seguir apresenta exemplos de dados reais armazenados durante os testes, demonstrando que as informações de rondas e ocorrências são corretamente processadas e persistidas, mantendo integridade referencial e rastreabilidade temporal.

**Figura 33 - Dados armazenados no banco de dados**

```
Tabela: ronda
┌────┬─────────────────────┬─────────────────────┬─────────────┬──────────┐
│ id │ data_hora_inicio    │ data_hora_fim       │ condominio  │ usuario  │
├────┼─────────────────────┼─────────────────────┼─────────────┼──────────┤
│ 1  │ 2025-01-15 18:11:00 │ 2025-01-15 18:31:00 │ Zermatt     │ admin    │
│ 2  │ 2025-01-15 19:24:00 │ 2025-01-15 19:49:00 │ Zermatt     │ admin    │
│ 3  │ 2025-01-15 21:04:00 │ 2025-01-15 21:24:00 │ Villa Verde │ admin    │
└────┴─────────────────────┴─────────────────────┴─────────────┴──────────┘

Tabela: ocorrencia
┌────┬─────────────────────┬─────────────┬─────────────┬──────────┐
│ id │ data_hora_ocorrencia│ tipo        │ condominio  │ status   │
├────┼─────────────────────┼─────────────┼─────────────┼──────────┤
│ 1  │ 2025-01-15 18:15:00 │ Roubo/Furto │ Zermatt     │ Ativa    │
│ 2  │ 2025-01-15 19:30:00 │ Vandalismo  │ Villa Verde │ Resolvida│
└────┴─────────────────────┴─────────────┴─────────────┴──────────┘
```

*Fonte: Elaborado pelo autor (2025)*

O sistema implementa funcionalidades administrativas completas para gerenciamento de usuários e permissões. A interface administrativa apresentada permite aos administradores controlar o acesso ao sistema, definir papéis e gerenciar o ciclo de vida dos usuários, demonstrando a robustez do sistema de controle de acesso implementado.

**Figura 34 - Tela de Administração de Usuários**

```
┌─────────────────────────────────────────────────────────────┐
│  Administração | Usuários | Condomínios | Configurações    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Lista de Usuários                      │   │
│  │                                                     │   │
│  │  Usuário    │ Email              │ Papel    │ Status│   │
│  │  admin      │ admin@sistema.com  │ Admin    │ Ativo │   │
│  │  supervisor │ super@sistema.com  │ Supervisor│ Ativo│   │
│  │  agente1    │ agente1@email.com  │ Agente   │ Ativo │   │
│  │  agente2    │ agente2@email.com  │ Agente   │ Inativo│   │
│  │                                                     │   │
│  │  [Adicionar Usuário] [Editar] [Excluir]            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

*Fonte: Elaborado pelo autor (2025)*

Como resultado final do processamento automatizado, o sistema gera relatórios formatados e estruturados das atividades de ronda. Esta saída demonstra como dados brutos de entrada são transformados em documentos profissionais e organizados, prontos para utilização em relatórios oficiais e análises gerenciais, evidenciando a eficácia do processamento inteligente implementado.

**Figura 35 - Relatório de Rondas Formatado**

```
Plantão 15/01/2025 (18h às 06h)
Residencial: ZERMATT

	Início: 18:11  – Término: 18:31 (20 min)
	Início: 19:24  – Término: 19:49 (25 min)
	Início: 22:28  – Término: 22:48 (20 min)
	Início: 00:17  – Término: 00:38 (21 min)
	Início: 01:49  – Término: 02:05 (16 min)
	Início: 03:01  – Término: 03:26 (25 min)
	Início: 04:30  – Término: 04:52 (22 min)

✅ Total: 7 rondas completas no plantão

Plantão 15/01/2025 (18h às 06h)
Residencial: VILLA VERDE

	Início: 21:04  – Término: 21:24 (20 min)

✅ Total: 1 ronda completa no plantão
```

*Fonte: Elaborado pelo autor (2025)*

## 5 CONSIDERAÇÕES FINAIS

O desenvolvimento do sistema web para gestão de segurança predial mostrou-se tecnicamente viável e economicamente acessível, graças ao uso de tecnologias amplamente difundidas e de baixo custo. A integração entre o backend Flask, banco de dados PostgreSQL e inteligência artificial validou o fluxo completo do sistema, desde a autenticação de usuários até a geração de relatórios automatizados.

A utilização da metodologia Scrum contribuiu significativamente para a organização do projeto, permitindo flexibilidade e correções rápidas durante o desenvolvimento. Os testes realizados comprovaram a eficiência do sistema na transmissão de dados com baixa latência e seu correto armazenamento no banco de dados PostgreSQL.

A interface desenvolvida com Bootstrap destacou-se pela usabilidade, responsividade e compatibilidade em diferentes dispositivos e navegadores. Além disso, a funcionalidade de classificação automática de ocorrências com IA e geração de relatórios históricos reforçou a utilidade do sistema para análises posteriores, agregando valor às informações coletadas pelos agentes de segurança.

A arquitetura baseada no padrão MVC facilitou a manutenção e evolução do código, enquanto a integração com Google Gemini proporcionou automação inteligente na classificação de ocorrências. O sistema de cache implementado otimizou significativamente o desempenho das consultas à API de IA.

Como sugestão para trabalhos futuros, é possível evoluir o sistema com funcionalidades como notificações em tempo real via WebSocket, integração com sistemas de monitoramento por câmeras, gráficos interativos mais avançados e suporte a múltiplos idiomas. Também é promissora a implementação de regras de alerta automáticas com base em padrões de ocorrências, aumentando a aplicabilidade do sistema em ambientes industriais e residenciais.

A implementação de testes automatizados com cobertura de 99% garante a qualidade e confiabilidade do sistema, enquanto a documentação técnica completa facilita a manutenção e evolução futura.

Assim, este trabalho apresenta uma solução prática, escalável e de código aberto que contribui para a modernização da gestão de segurança em condomínios e ambientes corporativos, demonstrando a viabilidade técnica e econômica da integração de tecnologias web modernas com inteligência artificial para o setor de segurança privada.

---

*Fonte: Elaborado pelo autor (2025)*
